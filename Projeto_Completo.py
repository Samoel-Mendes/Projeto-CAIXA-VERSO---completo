# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EzIJ2ZWES2Uq7Y_xqE-uTvZSEiphNL79

Estamos trabalhando com filmes/s√©ries de um cat√°logo, que deve conter pelo menos 20 filmes com as seguintes informa√ß√µes:

- Nome do filme
- Diretor (ou alguma outra informa√ß√£o textual)
- Avalia√ß√£o (do p√∫blico, idealmente de 0 a 10)
- Data de lan√ßamento
- Tupla indicando a dura√ß√£o do filme, formato (hora, minuto)
- Dispon√≠vel em servi√ßos de streaming (booleano)
"""

# Lista de filmes
filmes = [
    ("Avatar", "James Cameron", 7.8, "2009-12-18", (2, 42), True),
    ("Vingadores: Ultimato", "Irm√£os Russo", 8.4, "2019-04-26", (3, 1), True),
    ("Titanic", "James Cameron", 7.9, "1997-12-19", (3, 14), True),
    ("Star Wars: O Despertar da For√ßa", "J.J. Abrams", 7.8, "2015-12-18", (2, 18), True),
    ("Jurassic World", "Colin Trevorrow", 7.0, "2015-06-12", (2, 4), True),
    ("O Rei Le√£o", "Jon Favreau", 6.8, "2019-07-19", (1, 58), True),
    ("Os Vingadores", "Joss Whedon", 8.0, "2012-05-04", (2, 23), True),
    ("Velozes & Furiosos 7", "James Wan", 7.1, "2015-04-03", (2, 17), True),
    ("Frozen II", "Chris Buck", 6.8, "2019-11-22", (1, 43), True),
    ("Homem-Aranha: Sem Volta para Casa", "Jon Watts", 8.2, "2021-12-17", (2, 28), True),
    ("Harry Potter e as Rel√≠quias da Morte - Parte 2", "David Yates", 8.1, "2011-07-15", (2, 10), True),
    ("007 - Sem Tempo para Morrer", "Cary Fukunaga", 7.3, "2021-10-08", (2, 43), True),
    ("Duna", "Denis Villeneuve", 8.0, "2021-10-22", (2, 35), True),
    ("Top Gun: Maverick", "Joseph Kosinski", 8.5, "2022-05-27", (2, 17), False),
    ("Oppenheimer", "Christopher Nolan", 8.6, "2023-07-21", (3, 0), False),
    ("Barbie", "Greta Gerwig", 7.8, "2023-07-21", (1, 54), False),
    ("Avatar: O Caminho da √Ågua", "James Cameron", 7.6, "2022-12-16", (3, 12), False),
    ("Matrix Resurrections", "Lana Wachowski", 5.7, "2021-12-22", (2, 28), True),
    ("Eternos", "Chlo√© Zhao", 6.3, "2021-11-05", (2, 37), True),
    ("Miss√£o: Imposs√≠vel - Acerto de Contas", "Christopher McQuarrie", 7.8, "2023-07-14", (2, 43), False)
]

# Converter para lista de dicion√°rios
filmes_dict = []
for filme in filmes:
    filme_dict = {
        "nome": filme[0],
        "diretor": filme[1],
        "avaliacao": filme[2],
        "data_lancamento": filme[3],
        "duracao": filme[4],
        "streaming": filme[5]
    }
    filmes_dict.append(filme_dict)

# Salvar em arquivo JSON
with open("catalogo_filmes.json", "w", encoding="utf-8") as arquivo:
    json.dump(filmes_dict, arquivo, ensure_ascii=False, indent=2)

print("‚úÖ Arquivo JSON criado com sucesso: catalogo_filmes.json")
print(f"üìä Total de filmes convertidos: {len(filmes_dict)}")

"""Etapa 1: Obten√ß√£o dos dados
- Pedir ao usu√°rio os dados necess√°rios a partir do tema indicado no cat√°logo
- Todos os dados devem ser validados
- Guardar os dados em uma lista de dicion√°rios
- Exportar esta lista de dicion√°rios para um JSON

"""

# etapa1_cadastro_filmes.py
import json
from datetime import datetime
from typing import Dict, Any, List

class CadastroFilmes:
    def __init__(self):
        self.filmes = []

    def validar_nome(self, nome: str) -> bool:
        """Valida o nome do filme (m√≠nimo 2 caracteres)"""
        return len(nome.strip()) >= 2

    def validar_diretor(self, diretor: str) -> bool:
        """Valida o nome do diretor (m√≠nimo 3 caracteres)"""
        return len(diretor.strip()) >= 3

    def validar_avaliacao(self, avaliacao: str) -> bool:
        """Valida a avalia√ß√£o (0-10 com at√© 1 casa decimal)"""
        try:
            aval = float(avaliacao)
            return 0 <= aval <= 10 and len(avaliacao.split('.')[-1]) <= 1
        except ValueError:
            return False

    def validar_data(self, data_str: str) -> bool:
        """Valida a data no formato DD/MM/AAAA"""
        try:
            datetime.strptime(data_str, '%d/%m/%Y')
            return True
        except ValueError:
            return False

    def validar_duracao(self, horas: str, minutos: str) -> bool:
        """Valida a dura√ß√£o do filme"""
        try:
            h = int(horas)
            m = int(minutos)
            return h >= 0 and 0 <= m < 60
        except ValueError:
            return False

    def obter_entrada_validada(self, mensagem: str, funcao_validacao, mensagem_erro: str) -> str:
        """Obt√©m entrada do usu√°rio com valida√ß√£o"""
        while True:
            entrada = input(mensagem).strip()
            if funcao_validacao(entrada):
                return entrada
            print(mensagem_erro)

    def obter_dados_filme(self) -> Dict[str, Any]:
        """Obt√©m e valida os dados de um filme do usu√°rio"""
        print("\n" + "="*50)
        print("üìΩÔ∏è  CADASTRO DE FILME")
        print("="*50)

        # Nome do filme
        nome = self.obter_entrada_validada(
            "üé¨ Nome do filme: ",
            self.validar_nome,
            "‚ùå Nome inv√°lido! Deve ter pelo menos 2 caracteres."
        )

        # Diretor
        diretor = self.obter_entrada_validada(
            "üë®‚Äçüíº Diretor: ",
            self.validar_diretor,
            "‚ùå Diretor inv√°lido! Deve ter pelo menos 3 caracteres."
        )

        # Avalia√ß√£o
        avaliacao = self.obter_entrada_validada(
            "‚≠ê Avalia√ß√£o (0-10, ex: 7.5): ",
            self.validar_avaliacao,
            "‚ùå Avalia√ß√£o inv√°lida! Deve ser entre 0 e 10 com at√© 1 casa decimal."
        )

        # Data de lan√ßamento
        data_lancamento = self.obter_entrada_validada(
            "üìÖ Data de lan√ßamento (DD/MM/AAAA): ",
            self.validar_data,
            "‚ùå Data inv√°lida! Use o formato DD/MM/AAAA."
        )

        # Dura√ß√£o
        print("‚è∞ Dura√ß√£o do filme:")
        while True:
            try:
                horas = input("   Horas: ").strip()
                minutos = input("   Minutos: ").strip()
                if self.validar_duracao(horas, minutos):
                    break
                print("‚ùå Dura√ß√£o inv√°lida! Horas >= 0, minutos entre 0-59.")
            except ValueError:
                print("‚ùå Digite n√∫meros v√°lidos!")

        # Streaming
        while True:
            streaming = input("üì∫ Dispon√≠vel em streaming? (s/n): ").strip().lower()
            if streaming in ['s', 'sim']:
                streaming_bool = True
                break
            elif streaming in ['n', 'n√£o', 'nao']:
                streaming_bool = False
                break
            print("‚ùå Digite 's' para sim ou 'n' para n√£o!")

        return {
            'nome': nome,
            'diretor': diretor,
            'avaliacao': float(avaliacao),
            'data_lancamento': data_lancamento,
            'duracao': (int(horas), int(minutos)),
            'streaming': streaming_bool
        }

    def cadastrar_filmes(self, quantidade: int = 20):
        """Cadastra a quantidade especificada de filmes"""
        print("üéâ BEM-VINDO AO SISTEMA DE CAT√ÅLOGO DE FILMES!")
        print("üìä Vamos cadastrar os filmes de maior bilheteria.\n")

        for i in range(quantidade):
            print(f"üéûÔ∏è  Filme {i+1} de {quantidade}")
            filme = self.obter_dados_filme()
            self.filmes.append(filme)
            print("‚úÖ Filme cadastrado com sucesso!")

    def exportar_json(self, nome_arquivo: str = "catalogo_filmes.json"):
        """Exporta os filmes para um arquivo JSON"""
        try:
            with open(nome_arquivo, 'w', encoding='utf-8') as f:
                json.dump(self.filmes, f, ensure_ascii=False, indent=2)
            print(f"\nüíæ Dados exportados para: {nome_arquivo}")
            print(f"üìà Total de filmes cadastrados: {len(self.filmes)}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao exportar arquivo: {e}")
            return False

    def exibir_resumo_cadastro(self):
        """Exibe um resumo dos filmes cadastrados"""
        if not self.filmes:
            print("üì≠ Nenhum filme cadastrado!")
            return

        print("\n" + "="*60)
        print("üìã RESUMO DO CADASTRO")
        print("="*60)

        for i, filme in enumerate(self.filmes, 1):
            horas, minutos = filme['duracao']
            streaming = "‚úÖ" if filme['streaming'] else "‚ùå"
            print(f"{i:2d}. {filme['nome']}")
            print(f"   üë®‚Äçüíº Diretor: {filme['diretor']}")
            print(f"   ‚≠ê Avalia√ß√£o: {filme['avaliacao']}/10")
            print(f"   üìÖ Data: {filme['data_lancamento']}")
            print(f"   ‚è∞ Dura√ß√£o: {horas}h{minutos:02d}min")
            print(f"   üì∫ Streaming: {streaming}")
            print()

def main():
    """Fun√ß√£o principal da Etapa 1"""
    cadastro = CadastroFilmes()

    # Obter quantidade de filmes a cadastrar
    while True:
        try:
            quantidade = int(input("Quantos filmes deseja cadastrar? (padr√£o: 20): ") or "20")
            if quantidade > 0:
                break
            print("‚ùå Digite um n√∫mero positivo!")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido!")

    # Cadastrar filmes
    cadastro.cadastrar_filmes(quantidade)

    # Exportar para JSON
    if cadastro.exportar_json():
        # Exibir resumo
        cadastro.exibir_resumo_cadastro()

        # Mostrar local do arquivo
        print("\n" + "="*50)
        print("üéØ ETAPA 1 CONCLU√çDA COM SUCESSO!")
        print("="*50)
        print("üìÅ Arquivo JSON gerado: catalogo_filmes.json")
        print("‚û°Ô∏è  Execute a Etapa 2 para an√°lise estat√≠stica")

if __name__ == "__main__":
    main()

"""Etapa 2: Leitura e obten√ß√£o de estat√≠sticas
- Podemos ler estes dados do arquivo JSON
- Obter a m√©dia e a mediana da avali√ß√£o utilizando fun√ß√µes de alta ordem
- Obter uma lista com todos os nomes de filmes cuja avali√ß√£o √© maior que 6, utilizando uma fun√ß√£o pr√≥pria (deve possuir valores default nos par√¢metros)
- Obter uma lista com todos os nomes de filmes que existem em algum servi√ßo de streaming, utilizando list-comprehension
- Criar uma fun√ß√£o que retorna o filme que possui a maior e o filme que possui a menor dura√ß√£o dentre os cadastrados
- Obter a moda dos diretores (ou seja, o diretor que mais dirigiu filmes)

"""

# etapa2_estatisticas_filmes.py
import json
from collections import Counter
from typing import List, Dict, Tuple, Any

class EstatisticasFilmes:
    def __init__(self, arquivo_json: str = "catalogo_filmes.json"):
        self.arquivo_json = arquivo_json
        self.filmes = self.carregar_dados()

    def carregar_dados(self) -> List[Dict[str, Any]]:
        """Carrega os dados do arquivo JSON usando fun√ß√£o de alta ordem"""
        try:
            with open(self.arquivo_json, 'r', encoding='utf-8') as f:
                dados = json.load(f)
            print(f"‚úÖ Dados carregados: {len(dados)} filmes")
            return dados
        except FileNotFoundError:
            print(f"‚ùå Arquivo {self.arquivo_json} n√£o encontrado!")
            return []
        except json.JSONDecodeError:
            print(f"‚ùå Erro ao decodificar o arquivo JSON!")
            return []

    def calcular_media_avaliacao(self) -> float:
        """Calcula a m√©dia das avalia√ß√µes usando fun√ß√µes de alta ordem (map)"""
        if not self.filmes:
            return 0.0

        # Usando map para extrair as avalia√ß√µes
        avaliacoes = list(map(lambda filme: filme['avaliacao'], self.filmes))
        return sum(avaliacoes) / len(avaliacoes)

    def calcular_mediana_avaliacao(self) -> float:
        """Calcula a mediana das avalia√ß√µes usando fun√ß√µes de alta ordem (sorted, map)"""
        if not self.filmes:
            return 0.0

        # Usando sorted e map para ordenar as avalia√ß√µes
        avaliacoes = sorted(map(lambda filme: filme['avaliacao'], self.filmes))
        n = len(avaliacoes)

        # Mediana para lista par ou √≠mpar
        return (avaliacoes[n//2 - 1] + avaliacoes[n//2]) / 2 if n % 2 == 0 else avaliacoes[n//2]

    def filmes_acima_avaliacao(self, limite: float = 6.0, ordenar: bool = True) -> List[str]:
        """
        Retorna filmes com avalia√ß√£o acima do limite usando fun√ß√£o pr√≥pria com par√¢metros default
        Par√¢metros:
        - limite: float = 6.0 (valor default)
        - ordenar: bool = True (valor default)
        """
        if not self.filmes:
            return []

        # Filtra filmes acima do limite
        filmes_filtrados = [
            filme for filme in self.filmes
            if filme['avaliacao'] > limite
        ]

        # Ordena por avalia√ß√£o (decrescente) se solicitado
        if ordenar:
            filmes_filtrados.sort(key=lambda x: x['avaliacao'], reverse=True)

        return [filme['nome'] for filme in filmes_filtrados]

    def filmes_em_streaming(self) -> List[str]:
        """Retorna filmes dispon√≠veis em streaming usando list comprehension"""
        return [
            filme['nome'] for filme in self.filmes
            if filme['streaming']
        ]

    def duracao_em_minutos(self, duracao_tuple: Tuple[int, int]) -> int:
        """Converte tupla (horas, minutos) para minutos totais"""
        return duracao_tuple[0] * 60 + duracao_tuple[1]

    def extremos_duracao(self) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Retorna o filme com maior e menor dura√ß√£o
        Usa fun√ß√µes de alta ordem (max, min, lambda)
        """
        if not self.filmes:
            return {}, {}

        # Encontra filmes com maior e menor dura√ß√£o usando lambda
        mais_longo = max(self.filmes, key=lambda x: self.duracao_em_minutos(x['duracao']))
        mais_curto = min(self.filmes, key=lambda x: self.duracao_em_minutos(x['duracao']))

        return mais_longo, mais_curto

    def moda_diretores(self) -> List[Tuple[str, int]]:
        """Retorna a moda dos diretores (os que mais dirigiram filmes) usando Counter"""
        if not self.filmes:
            return []

        # Usando list comprehension para extrair diretores
        diretores = [filme['diretor'] for filme in self.filmes]

        # Usando Counter para contar ocorr√™ncias
        contador = Counter(diretores)

        if not contador:
            return []

        # Encontra a contagem m√°xima
        max_contagem = max(contador.values())

        # Retorna todos os diretores com a contagem m√°xima
        return [
            (diretor, contagem) for diretor, contagem in contador.items()
            if contagem == max_contagem
        ]

    def formatar_duracao(self, duracao_tuple: Tuple[int, int]) -> str:
        """Formata a dura√ß√£o para exibi√ß√£o amig√°vel"""
        horas, minutos = duracao_tuple
        return f"{horas}h{minutos:02d}min"

    def exibir_estatisticas_completas(self):
        """Exibe todas as estat√≠sticas do cat√°logo"""
        if not self.filmes:
            print("‚ùå Nenhum dado dispon√≠vel para an√°lise!")
            return

        print("\n" + "="*70)
        print("üìä AN√ÅLISE ESTAT√çSTICA DO CAT√ÅLOGO DE FILMES")
        print("="*70)

        # Estat√≠sticas b√°sicas
        print(f"üé¨ Total de filmes analisados: {len(self.filmes)}")
        print(f"‚≠ê M√©dia de avalia√ß√µes: {self.calcular_media_avaliacao():.2f}/10")
        print(f"üìà Mediana de avalia√ß√µes: {self.calcular_mediana_avaliacao():.2f}/10")

        # Filmes com avalia√ß√£o > 6 (usando fun√ß√£o com par√¢metros default)
        filmes_acima_6 = self.filmes_acima_avaliacao()
        print(f"\nüèÜ Filmes com avalia√ß√£o > 6.0: {len(filmes_acima_6)}")
        for i, filme in enumerate(filmes_acima_6, 1):
            # Encontra a avalia√ß√£o do filme para exibir
            avaliacao = next((f['avaliacao'] for f in self.filmes if f['nome'] == filme), "N/A")
            print(f"   {i:2d}. {filme} ‚≠ê {avaliacao}")

        # Filmes em streaming (usando list comprehension)
        filmes_streaming = self.filmes_em_streaming()
        print(f"\nüì∫ Filmes dispon√≠veis em streaming: {len(filmes_streaming)}")
        for i, filme in enumerate(filmes_streaming, 1):
            print(f"   {i:2d}. {filme}")

        # Extremos de dura√ß√£o
        mais_longo, mais_curto = self.extremos_duracao()
        if mais_longo and mais_curto:
            print(f"\n‚è∞ Filme mais longo: {mais_longo['nome']}")
            print(f"   üë®‚Äçüíº Diretor: {mais_longo['diretor']}")
            print(f"   ‚è±Ô∏è  Dura√ß√£o: {self.formatar_duracao(mais_longo['duracao'])}")

            print(f"\n‚è±Ô∏è  Filme mais curto: {mais_curto['nome']}")
            print(f"   üë®‚Äçüíº Diretor: {mais_curto['diretor']}")
            print(f"   ‚è∞ Dura√ß√£o: {self.formatar_duracao(mais_curto['duracao'])}")

        # Moda dos diretores
        moda_diretores = self.moda_diretores()
        if moda_diretores:
            print(f"\nüé≠ Diretor(es) mais frequente(s):")
            for diretor, contagem in moda_diretores:
                print(f"   üë®‚Äçüíº {diretor}: {contagem} filme(s)")

                # Lista filmes desse diretor
                filmes_diretor = [f['nome'] for f in self.filmes if f['diretor'] == diretor]
                for filme in filmes_diretor:
                    print(f"      üé¨ {filme}")

        # Estat√≠sticas adicionais
        self.exibir_estatisticas_adicionais()

    def exibir_estatisticas_adicionais(self):
        """Exibe estat√≠sticas adicionais interessantes"""
        print(f"\n" + "="*70)
        print("üìà ESTAT√çSTICAS ADICIONAIS")
        print("="*70)

        # Porcentagem em streaming
        total_streaming = len(self.filmes_em_streaming())
        porcentagem = (total_streaming / len(self.filmes)) * 100
        print(f"üìä Porcentagem em streaming: {porcentagem:.1f}%")

        # Filme melhor avaliado
        melhor_avaliado = max(self.filmes, key=lambda x: x['avaliacao'])
        print(f"üèÖ Melhor avaliado: {melhor_avaliado['nome']} ‚≠ê {melhor_avaliado['avaliacao']}")

        # Filme pior avaliado
        pior_avaliado = min(self.filmes, key=lambda x: x['avaliacao'])
        print(f"‚ö´ Pior avaliado: {pior_avaliado['nome']} ‚≠ê {pior_avaliado['avaliacao']}")

        # Dura√ß√£o m√©dia
        duracoes = [self.duracao_em_minutos(f['duracao']) for f in self.filmes]
        duracao_media_min = sum(duracoes) / len(duracoes)
        horas = int(duracao_media_min // 60)
        minutos = int(duracao_media_min % 60)
        print(f"‚è∞ Dura√ß√£o m√©dia: {horas}h{minutos:02d}min")

    def demonstrar_funcoes_avaliacao(self):
        """Demonstra o uso da fun√ß√£o com par√¢metros default"""
        print(f"\n" + "="*70)
        print("üîß DEMONSTRA√á√ÉO DA FUN√á√ÉO filmes_acima_avaliacao()")
        print("="*70)

        # Com par√¢metros default (limite=6.0, ordenar=True)
        print("üìã Com par√¢metros default (limite=6.0, ordenar=True):")
        filmes_default = self.filmes_acima_avaliacao()
        print(f"   Encontrados: {len(filmes_default)} filmes")

        # Com limite personalizado
        print("\nüìã Com limite=7.5, ordenar=True:")
        filmes_75 = self.filmes_acima_avaliacao(limite=7.5)
        print(f"   Encontrados: {len(filmes_75)} filmes")
        for filme in filmes_75:
            print(f"      üé¨ {filme}")

        # Sem ordena√ß√£o
        print("\nüìã Com limite=6.0, ordenar=False:")
        filmes_nao_ordenados = self.filmes_acima_avaliacao(ordenar=False)
        print(f"   Encontrados: {len(filmes_nao_ordenados)} filmes (ordem original)")

# Execu√ß√£o da Etapa 2
def main():
    print("üé¨ ETAPA 2: AN√ÅLISE ESTAT√çSTICA DE FILMES")
    print("="*55)
    print("üìä Gerando estat√≠sticas a partir do arquivo JSON...")

    # Carregar dados e analisar
    estatisticas = EstatisticasFilmes("catalogo_filmes.json")

    if estatisticas.filmes:
        # Exibir estat√≠sticas completas
        estatisticas.exibir_estatisticas_completas()

        # Demonstrar fun√ß√£o com par√¢metros default
        estatisticas.demonstrar_funcoes_avaliacao()

        print(f"\n" + "="*70)
        print("‚úÖ ETAPA 2 CONCLU√çDA COM SUCESSO!")
        print("="*70)
    else:
        print("‚ùå N√£o foi poss√≠vel carregar dados para an√°lise.")

if __name__ == "__main__":
    main()

"""ETAPAS 3 E 4 - Dados desestruturados

Etapa 3: Lidando com dados desestruturados
- Foi indicado que a m√©dia da turma deve ser a mesma m√©dia da lista de notas abaixo:

[[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]

- Crie uma fun√ß√£o recursiva para obter a m√©dia da lista acima
- Utilize esta m√©dia e crie uma fun√ß√£o para "garantir" que a m√©dia da turma fique igual a esta m√©dia retornada por essa fun√ß√£o
- Atualize as m√©dias dos alunos e exporte os novos dados em formato CSV
"""

# etapa3_dados_desestruturados.py
import csv
from typing import List, Any, Union

class ProcessadorDadosDesestruturados:
    def __init__(self):
        self.dados_desestruturados = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]

    def achatamento_recursivo(self, dados: Any) -> List[float]:
        """
        Fun√ß√£o recursiva para achatamento de lista aninhada
        Converte qualquer estrutura aninhada em lista plana de n√∫meros
        """
        lista_plana = []

        if isinstance(dados, (int, float)):
            lista_plana.append(float(dados))
        elif isinstance(dados, list):
            for item in dados:
                lista_plana.extend(self.achatamento_recursivo(item))
        else:
            # Ignora tipos n√£o num√©ricos ou converte se poss√≠vel
            try:
                lista_plana.append(float(dados))
            except (ValueError, TypeError):
                pass

        return lista_plana

    def calcular_media_recursiva(self, dados: Any = None) -> float:
        """
        Fun√ß√£o recursiva para calcular m√©dia de lista aninhada
        """
        if dados is None:
            dados = self.dados_desestruturados

        lista_plana = self.achatamento_recursivo(dados)

        if not lista_plana:
            return 0.0

        return sum(lista_plana) / len(lista_plana)

    def ajustar_medias_alunos(self, dados_alunos: List[Dict], media_alvo: float) -> List[Dict]:
        """
        Ajusta as m√©dias dos alunos para atingir a m√©dia alvo
        Mant√©m a distribui√ß√£o relativa das notas
        """
        if not dados_alunos:
            return []

        # Calcula m√©dia atual dos alunos
        medias_atuais = [aluno.get('media', 0) for aluno in dados_alunos]
        media_atual = sum(medias_atuais) / len(medias_atuais) if medias_atuais else 0

        if media_atual == 0:
            return dados_alunos

        # Fator de ajuste proporcional
        fator_ajuste = media_alvo / media_atual

        # Aplica ajuste mantendo a distribui√ß√£o relativa
        for aluno in dados_alunos:
            if 'media' in aluno:
                aluno['media_ajustada'] = round(aluno['media'] * fator_ajuste, 2)
                # Garante que a nota fique entre 0 e 10
                aluno['media_ajustada'] = max(0, min(10, aluno['media_ajustada']))

        return dados_alunos

    def criar_dados_alunos_exemplo(self) -> List[Dict]:
        """
        Cria dados de exemplo de alunos com m√©dias variadas
        """
        return [
            {'id': 1, 'nome': 'Ana Silva', 'media': 8.5},
            {'id': 2, 'nome': 'Carlos Oliveira', 'media': 6.2},
            {'id': 3, 'nome': 'Maria Santos', 'media': 9.1},
            {'id': 4, 'nome': 'Jo√£o Pereira', 'media': 7.3},
            {'id': 5, 'nome': 'Fernanda Costa', 'media': 5.8},
            {'id': 6, 'nome': 'Ricardo Almeida', 'media': 8.9},
            {'id': 7, 'nome': 'Juliana Rodrigues', 'media': 6.7},
            {'id': 8, 'nome': 'Pedro Mendes', 'media': 7.8},
            {'id': 9, 'nome': 'Camila Ferreira', 'media': 4.5},
            {'id': 10, 'nome': 'Lucas Souza', 'media': 9.5}
        ]

    def exportar_csv(self, dados: List[Dict], nome_arquivo: str = 'alunos_medias_ajustadas.csv'):
        """
        Exporta os dados para arquivo CSV
        """
        if not dados:
            print("‚ùå Nenhum dado para exportar!")
            return False

        try:
            with open(nome_arquivo, 'w', newline='', encoding='utf-8') as csvfile:
                campos = list(dados[0].keys())
                writer = csv.DictWriter(csvfile, fieldnames=campos)

                writer.writeheader()
                for aluno in dados:
                    writer.writerow(aluno)

            print(f"‚úÖ Dados exportados para: {nome_arquivo}")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao exportar CSV: {e}")
            return False

    def demonstrar_processamento(self):
        """
        Demonstra todo o processo de forma clara
        """
        print("üéØ ETAPA 3: PROCESSAMENTO DE DADOS DESESTRUTURADOS")
        print("=" * 55)

        # 1. Mostrar dados desestruturados
        print("üìä Dados desestruturados:")
        print(f"   {self.dados_desestruturados}")

        # 2. Achatamento recursivo
        lista_plana = self.achatamento_recursivo(self.dados_desestruturados)
        print(f"\nüìã Lista achatada (recursivo):")
        print(f"   {lista_plana}")
        print(f"   Quantidade de elementos: {len(lista_plana)}")

        # 3. C√°lculo da m√©dia recursiva
        media_alvo = self.calcular_media_recursiva()
        print(f"\nüìà M√©dia calculada (recursiva): {media_alvo:.2f}")

        # 4. Criar dados de exemplo
        dados_alunos = self.criar_dados_alunos_exemplo()
        media_original = sum(aluno['media'] for aluno in dados_alunos) / len(dados_alunos)
        print(f"\nüë• Dados originais dos alunos:")
        print(f"   M√©dia original da turma: {media_original:.2f}")

        # 5. Ajustar m√©dias
        dados_ajustados = self.ajustar_medias_alunos(dados_alunos, media_alvo)
        media_ajustada = sum(aluno['media_ajustada'] for aluno in dados_ajustados) / len(dados_ajustados)
        print(f"   M√©dia ajustada da turma: {media_ajustada:.2f}")

        # 6. Mostrar compara√ß√£o
        print(f"\nüìä Compara√ß√£o das m√©dias:")
        for aluno in dados_ajustados:
            print(f"   {aluno['nome']:15} | Original: {aluno['media']:4.1f} | Ajustada: {aluno['media_ajustada']:4.1f}")

        # 7. Exportar CSV
        if self.exportar_csv(dados_ajustados):
            print(f"\nüíæ Arquivo CSV criado com sucesso!")

        return dados_ajustados

# Fun√ß√£o recursiva independente (como solicitado)
def calcular_media_recursiva(dados: Any) -> float:
    """
    Fun√ß√£o recursiva pura para calcular m√©dia de lista aninhada
    """
    def achatamento_recursivo(item: Any) -> List[float]:
        if isinstance(item, (int, float)):
            return [float(item)]
        elif isinstance(item, list):
            lista_plana = []
            for subitem in item:
                lista_plana.extend(achatamento_recursivo(subitem))
            return lista_plana
        else:
            return []

    lista_plana = achatamento_recursivo(dados)
    return sum(lista_plana) / len(lista_plana) if lista_plana else 0.0

# Execu√ß√£o principal
if __name__ == "__main__":
    # Criar processador
    processador = ProcessadorDadosDesestruturados()

    # Demonstrar processamento completo
    dados_finais = processador.demonstrar_processamento()

    # Demonstrar fun√ß√£o recursiva independente
    print(f"\nüîç Fun√ß√£o recursiva independente:")
    dados_test = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]
    media = calcular_media_recursiva(dados_test)
    print(f"   M√©dia calculada: {media:.2f}")

"""Etapa 4: Tratamento de exce√ß√µes
- Tratar os poss√≠veis erros do c√≥digo e exce√ß√µes

"""

import csv
from typing import List, Any, Union, Dict, Optional

class ProcessadorDadosDesestruturados:
    def __init__(self):
        self.dados_desestruturados = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]

    def achatamento_recursivo(self, dados: Any) -> List[float]:
        """
        Fun√ß√£o recursiva para achatamento de lista aninhada
        Converte qualquer estrutura aninhada em lista plana de n√∫meros
        """
        lista_plana = []

        try:
            if isinstance(dados, (int, float)):
                lista_plana.append(float(dados))
            elif isinstance(dados, list):
                for item in dados:
                    lista_plana.extend(self.achatamento_recursivo(item))
            elif isinstance(dados, str):
                # Tenta converter string para float se poss√≠vel
                try:
                    lista_plana.append(float(dados))
                except ValueError:
                    pass  # Ignora strings n√£o num√©ricas
            else:
                # Tenta converter outros tipos para float
                try:
                    lista_plana.append(float(dados))
                except (ValueError, TypeError):
                    pass  # Ignora tipos n√£o convers√≠veis

        except RecursionError:
            print("‚ùå Erro: Limite de recurs√£o excedido! Verifique dados muito aninhados.")
            return []
        except Exception as e:
            print(f"‚ùå Erro inesperado em achatamento_recursivo: {e}")
            return []

        return lista_plana

    def calcular_media_recursiva(self, dados: Any = None) -> float:
        """
        Fun√ß√£o recursiva para calcular m√©dia de lista aninhada
        """
        try:
            if dados is None:
                dados = self.dados_desestruturados

            lista_plana = self.achatamento_recursivo(dados)

            if not lista_plana:
                print("‚ö†Ô∏è  Aviso: Lista vazia ap√≥s achatamento. Retornando 0.0")
                return 0.0

            media = sum(lista_plana) / len(lista_plana)
            return round(media, 2)

        except ZeroDivisionError:
            print("‚ùå Erro: Divis√£o por zero ao calcular m√©dia")
            return 0.0
        except TypeError as e:
            print(f"‚ùå Erro de tipo ao calcular m√©dia: {e}")
            return 0.0
        except Exception as e:
            print(f"‚ùå Erro inesperado em calcular_media_recursiva: {e}")
            return 0.0

    def ajustar_medias_alunos(self, dados_alunos: List[Dict], media_alvo: float) -> List[Dict]:
        """
        Ajusta as m√©dias dos alunos para atingir a m√©dia alvo
        Mant√©m a distribui√ß√£o relativa das notas
        """
        if not dados_alunos:
            print("‚ö†Ô∏è  Aviso: Lista de alunos vazia")
            return []

        try:
            # Valida√ß√£o dos dados de entrada
            if not isinstance(dados_alunos, list):
                raise TypeError("dados_alunos deve ser uma lista")

            if not isinstance(media_alvo, (int, float)):
                raise TypeError("media_alvo deve ser um n√∫mero")

            # Calcula m√©dia atual dos alunos com tratamento de erros
            medias_atuais = []
            for aluno in dados_alunos:
                try:
                    if isinstance(aluno, dict) and 'media' in aluno:
                        media_val = aluno['media']
                        if isinstance(media_val, (int, float)):
                            medias_atuais.append(float(media_val))
                        else:
                            print(f"‚ö†Ô∏è  Aviso: M√©dia inv√°lida para aluno {aluno.get('nome', 'Desconhecido')}")
                except (KeyError, TypeError, ValueError) as e:
                    print(f"‚ö†Ô∏è  Aviso: Erro ao processar m√©dia do aluno: {e}")
                    continue

            if not medias_atuais:
                print("‚ùå Erro: Nenhuma m√©dia v√°lida encontrada")
                return dados_alunos

            media_atual = sum(medias_atuais) / len(medias_atuais)

            if media_atual == 0:
                print("‚ö†Ô∏è  Aviso: M√©dia atual √© zero, n√£o √© poss√≠vel ajustar")
                return dados_alunos

            # Fator de ajuste proporcional
            fator_ajuste = media_alvo / media_atual

            # Aplica ajuste mantendo a distribui√ß√£o relativa
            for aluno in dados_alunos:
                try:
                    if isinstance(aluno, dict) and 'media' in aluno:
                        media_original = aluno['media']
                        if isinstance(media_original, (int, float)):
                            media_ajustada = round(media_original * fator_ajuste, 2)
                            # Garante que a nota fique entre 0 e 10
                            aluno['media_ajustada'] = max(0.0, min(10.0, media_ajustada))
                        else:
                            aluno['media_ajustada'] = 0.0
                except (TypeError, ValueError) as e:
                    print(f"‚ùå Erro ao ajustar m√©dia do aluno {aluno.get('nome', 'Desconhecido')}: {e}")
                    aluno['media_ajustada'] = 0.0

            return dados_alunos

        except ZeroDivisionError:
            print("‚ùå Erro: Divis√£o por zero no ajuste de m√©dias")
            return dados_alunos
        except Exception as e:
            print(f"‚ùå Erro inesperado em ajustar_medias_alunos: {e}")
            return dados_alunos

    def criar_dados_alunos_exemplo(self) -> List[Dict]:
        """
        Cria dados de exemplo de alunos com m√©dias variadas
        """
        try:
            return [
                {'id': 1, 'nome': 'Ana Silva', 'media': 8.5},
                {'id': 2, 'nome': 'Carlos Oliveira', 'media': 6.2},
                {'id': 3, 'nome': 'Maria Santos', 'media': 9.1},
                {'id': 4, 'nome': 'Jo√£o Pereira', 'media': 7.3},
                {'id': 5, 'nome': 'Fernanda Costa', 'media': 5.8},
                {'id': 6, 'nome': 'Ricardo Almeida', 'media': 8.9},
                {'id': 7, 'nome': 'Juliana Rodrigues', 'media': 6.7},
                {'id': 8, 'nome': 'Pedro Mendes', 'media': 7.8},
                {'id': 9, 'nome': 'Camila Ferreira', 'media': 4.5},
                {'id': 10, 'nome': 'Lucas Souza', 'media': 9.5}
            ]
        except Exception as e:
            print(f"‚ùå Erro ao criar dados de exemplo: {e}")
            return []

    def exportar_csv(self, dados: List[Dict], nome_arquivo: str = 'alunos_medias_ajustadas.csv') -> bool:
        """
        Exporta os dados para arquivo CSV com tratamento robusto de erros
        """
        if not dados:
            print("‚ùå Nenhum dado para exportar!")
            return False

        if not isinstance(dados, list) or not all(isinstance(item, dict) for item in dados):
            print("‚ùå Dados devem ser uma lista de dicion√°rios")
            return False

        try:
            with open(nome_arquivo, 'w', newline='', encoding='utf-8') as csvfile:
                campos = list(dados[0].keys())
                writer = csv.DictWriter(csvfile, fieldnames=campos)

                writer.writeheader()
                for i, aluno in enumerate(dados):
                    try:
                        writer.writerow(aluno)
                    except ValueError as e:
                        print(f"‚ö†Ô∏è  Aviso: Erro ao escrever linha {i+1}: {e}")
                        # Tenta escrever dados sanitizados
                        linha_sanitizada = {k: str(v) for k, v in aluno.items()}
                        writer.writerow(linha_sanitizada)

            print(f"‚úÖ Dados exportados para: {nome_arquivo}")
            return True

        except PermissionError:
            print(f"‚ùå Erro de permiss√£o: N√£o √© poss√≠vel escrever no arquivo {nome_arquivo}")
            return False
        except FileNotFoundError:
            print(f"‚ùå Erro: Caminho inv√°lido para o arquivo {nome_arquivo}")
            return False
        except Exception as e:
            print(f"‚ùå Erro inesperado ao exportar CSV: {e}")
            return False

    def testar_cenarios_erro(self):
        """
        Testa diversos cen√°rios de erro para demonstrar o tratamento
        """
        print("\n" + "="*60)
        print("üß™ TESTANDO CEN√ÅRIOS DE ERRO")
        print("="*60)

        # Teste 1: Dados inv√°lidos na lista aninhada
        print("\n1. Testando dados inv√°lidos na lista:")
        dados_invalidos = [[6.3, "texto", [8.4, None, 5.1], 9.6], [], "string", {"dict": "value"}]
        media_invalida = self.calcular_media_recursiva(dados_invalidos)
        print(f"   M√©dia com dados inv√°lidos: {media_invalida:.2f}")

        # Teste 2: Lista vazia
        print("\n2. Testando lista vazia:")
        media_vazia = self.calcular_media_recursiva([])
        print(f"   M√©dia de lista vazia: {media_vazia:.2f}")

        # Teste 3: Ajuste com m√©dia zero
        print("\n3. Testando ajuste com m√©dia zero:")
        alunos_media_zero = [{'nome': 'Teste', 'media': 0}]
        ajustados = self.ajustar_medias_alunos(alunos_media_zero, 6.41)
        print(f"   Resultado: {ajustados}")

        # Teste 4: Exporta√ß√£o com erro de permiss√£o
        print("\n4. Testando exporta√ß√£o para caminho inv√°lido:")
        dados_teste = [{'teste': 'valor'}]
        resultado = self.exportar_csv(dados_teste, '/caminho/invalido/arquivo.csv')
        print(f"   Exporta√ß√£o bem-sucedida: {resultado}")

    def demonstrar_processamento(self):
        """
        Demonstra todo o processo de forma clara com tratamento de erros
        """
        print("üéØ ETAPA 4: PROCESSAMENTO COM TRATAMENTO DE EXCE√á√ïES")
        print("=" * 60)

        try:
            # 1. Mostrar dados desestruturados
            print("üìä Dados desestruturados:")
            print(f"   {self.dados_desestruturados}")

            # 2. Achatamento recursivo
            lista_plana = self.achatamento_recursivo(self.dados_desestruturados)
            print(f"\nüìã Lista achatada (recursivo):")
            print(f"   {lista_plana}")
            print(f"   Quantidade de elementos: {len(lista_plana)}")

            # 3. C√°lculo da m√©dia recursiva
            media_alvo = self.calcular_media_recursiva()
            print(f"\nüìà M√©dia calculada (recursiva): {media_alvo:.2f}")

            # 4. Criar dados de exemplo
            dados_alunos = self.criar_dados_alunos_exemplo()
            if not dados_alunos:
                raise ValueError("N√£o foi poss√≠vel criar dados de exemplo")

            media_original = sum(aluno['media'] for aluno in dados_alunos) / len(dados_alunos)
            print(f"\nüë• Dados originais dos alunos:")
            print(f"   M√©dia original da turma: {media_original:.2f}")

            # 5. Ajustar m√©dias
            dados_ajustados = self.ajustar_medias_alunos(dados_alunos, media_alvo)
            if not dados_ajustados:
                raise ValueError("Falha no ajuste de m√©dias")

            media_ajustada = sum(aluno.get('media_ajustada', 0) for aluno in dados_ajustados) / len(dados_ajustados)
            print(f"   M√©dia ajustada da turma: {media_ajustada:.2f}")

            # 6. Mostrar compara√ß√£o
            print(f"\nüìä Compara√ß√£o das m√©dias:")
            for aluno in dados_ajustados:
                print(f"   {aluno['nome']:18} | Original: {aluno['media']:4.1f} | Ajustada: {aluno.get('media_ajustada', 'N/A'):4.1f}")

            # 7. Exportar CSV
            if self.exportar_csv(dados_ajustados):
                print(f"\nüíæ Arquivo CSV criado com sucesso!")

            return dados_ajustados

        except Exception as e:
            print(f"‚ùå ERRO CR√çTICO no processamento: {e}")
            return []

# Fun√ß√£o recursiva independente com tratamento de erros
def calcular_media_recursiva(dados: Any) -> float:
    """
    Fun√ß√£o recursiva pura para calcular m√©dia de lista aninhada
    com tratamento robusto de exce√ß√µes
    """
    def achatamento_recursivo(item: Any) -> List[float]:
        try:
            if isinstance(item, (int, float)):
                return [float(item)]
            elif isinstance(item, list):
                lista_plana = []
                for subitem in item:
                    lista_plana.extend(achatamento_recursivo(subitem))
                return lista_plana
            elif isinstance(item, str):
                try:
                    return [float(item)]
                except ValueError:
                    return []
            else:
                return []
        except RecursionError:
            print("‚ùå Erro: Limite de recurs√£o excedido!")
            return []
        except Exception as e:
            print(f"‚ùå Erro inesperado em achatamento recursivo: {e}")
            return []

    try:
        lista_plana = achatamento_recursivo(dados)
        if not lista_plana:
            return 0.0
        return round(sum(lista_plana) / len(lista_plana), 2)
    except ZeroDivisionError:
        return 0.0
    except Exception as e:
        print(f"‚ùå Erro inesperado no c√°lculo da m√©dia: {e}")
        return 0.0

# Execu√ß√£o principal com tratamento completo de erros
if __name__ == "__main__":
    try:
        # Criar processador
        processador = ProcessadorDadosDesestruturados()

        # Demonstrar processamento completo
        dados_finais = processador.demonstrar_processamento()

        # Testar cen√°rios de erro
        processador.testar_cenarios_erro()

        # Demonstrar fun√ß√£o recursiva independente
        print(f"\nüîç Fun√ß√£o recursiva independente:")
        dados_test = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]
        media = calcular_media_recursiva(dados_test)
        print(f"   M√©dia calculada: {media:.2f}")

        # Teste com dados problem√°ticos
        print(f"\nüîç Teste com dados problem√°ticos:")
        dados_problematicos = ["texto", None, [], [1, 2, "3a"]]
        media_problema = calcular_media_recursiva(dados_problematicos)
        print(f"   M√©dia de dados problem√°ticos: {media_problema:.2f}")

    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Execu√ß√£o interrompida pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå ERRO GRAVE n√£o tratado: {e}")
    finally:
        print("\n‚úÖ Execu√ß√£o conclu√≠da com tratamento de exce√ß√µes completo!")