# -*- coding: utf-8 -*-
"""Projeto Completo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EzIJ2ZWES2Uq7Y_xqE-uTvZSEiphNL79

Estamos trabalhando com filmes/séries de um catálogo, que deve conter pelo menos 20 filmes com as seguintes informações:

- Nome do filme
- Diretor (ou alguma outra informação textual)
- Avaliação (do público, idealmente de 0 a 10)
- Data de lançamento
- Tupla indicando a duração do filme, formato (hora, minuto)
- Disponível em serviços de streaming (booleano)
"""

import json

filmes = [
    ("Avatar", "James Cameron", 7.8, "2009-12-18", (2, 42), True),
    ("Vingadores: Ultimato", "Irmãos Russo", 8.4, "2019-04-26", (3, 1), True),
    ("Titanic", "James Cameron", 7.9, "1997-12-19", (3, 14), True),
    ("Star Wars: O Despertar da Força", "J.J. Abrams", 7.8, "2015-12-18", (2, 18), True),
    ("Jurassic World", "Colin Trevorrow", 7.0, "2015-06-12", (2, 4), True),
    ("O Rei Leão", "Jon Favreau", 6.8, "2019-07-19", (1, 58), True),
    ("Os Vingadores", "Joss Whedon", 8.0, "2012-05-04", (2, 23), True),
    ("Velozes & Furiosos 7", "James Wan", 7.1, "2015-04-03", (2, 17), True),
    ("Frozen II", "Chris Buck", 6.8, "2019-11-22", (1, 43), True),
    ("Homem-Aranha: Sem Volta para Casa", "Jon Watts", 8.2, "2021-12-17", (2, 28), True),
    ("Harry Potter e as Relíquias da Morte - Parte 2", "David Yates", 8.1, "2011-07-15", (2, 10), True),
    ("007 - Sem Tempo para Morrer", "Cary Fukunaga", 7.3, "2021-10-08", (2, 43), True),
    ("Duna", "Denis Villeneuve", 8.0, "2021-10-22", (2, 35), True),
    ("Top Gun: Maverick", "Joseph Kosinski", 8.5, "2022-05-27", (2, 17), False),
    ("Oppenheimer", "Christopher Nolan", 8.6, "2023-07-21", (3, 0), False),
    ("Barbie", "Greta Gerwig", 7.8, "2023-07-21", (1, 54), False),
    ("Avatar: O Caminho da Água", "James Cameron", 7.6, "2022-12-16", (3, 12), False),
    ("Matrix Resurrections", "Lana Wachowski", 5.7, "2021-12-22", (2, 28), True),
    ("Eternos", "Chloé Zhao", 6.3, "2021-11-05", (2, 37), True),
    ("Missão: Impossível - Acerto de Contas", "Christopher McQuarrie", 7.8, "2023-07-14", (2, 43), False)
]

filmes_dict = []
for filme in filmes:
    filme_dict = {
        "nome": filme[0],
        "diretor": filme[1],
        "avaliacao": filme[2],
        "data_lancamento": filme[3],
        "duracao": filme[4],
        "streaming": filme[5]
    }
    filmes_dict.append(filme_dict)

with open("catalogo_filmes.json", "w", encoding="utf-8") as arquivo:
    json.dump(filmes_dict, arquivo, ensure_ascii=False, indent=2)

print("Arquivo JSON criado com sucesso: catalogo_filmes.json")
print(f"Total de filmes convertidos: {len(filmes_dict)}")

"""Etapa 1: Obtenção dos dados
- Pedir ao usuário os dados necessários a partir do tema indicado no catálogo
- Todos os dados devem ser validados
- Guardar os dados em uma lista de dicionários
- Exportar esta lista de dicionários para um JSON

"""

import json
from datetime import datetime
from typing import Dict, Any, List

class CadastroFilmes:
    def __init__(self):
        self.filmes = []

    def validar_nome(self, nome: str) -> bool:
        """Valida o nome do filme (mínimo 2 caracteres)"""
        return len(nome.strip()) >= 2

    def validar_diretor(self, diretor: str) -> bool:
        """Valida o nome do diretor (mínimo 3 caracteres)"""
        return len(diretor.strip()) >= 3

    def validar_avaliacao(self, avaliacao: str) -> bool:
        """Valida a avaliação (0-10 com até 1 casa decimal)"""
        try:
            aval = float(avaliacao)
            return 0 <= aval <= 10 and len(avaliacao.split('.')[-1]) <= 1
        except ValueError:
            return False

    def validar_data(self, data_str: str) -> bool:
        """Valida a data no formato DD/MM/AAAA"""
        try:
            datetime.strptime(data_str, '%d/%m/%Y')
            return True
        except ValueError:
            return False

    def validar_duracao(self, horas: str, minutos: str) -> bool:
        """Valida a duração do filme"""
        try:
            h = int(horas)
            m = int(minutos)
            return h >= 0 and 0 <= m < 60
        except ValueError:
            return False

    def obter_entrada_validada(self, mensagem: str, funcao_validacao, mensagem_erro: str) -> str:
        """Obtém entrada do usuário com validação"""
        while True:
            entrada = input(mensagem).strip()
            if funcao_validacao(entrada):
                return entrada
            print(mensagem_erro)

    def obter_dados_filme(self) -> Dict[str, Any]:
        """Obtém e valida os dados de um filme do usuário"""
        print("\n" + "="*50)
        print("CADASTRO DE FILME")
        print("="*50)

        nome = self.obter_entrada_validada(
            "Nome do filme: ",
            self.validar_nome,
            "Nome invalido! Deve ter pelo menos 2 caracteres."
        )

        diretor = self.obter_entrada_validada(
            "Diretor: ",
            self.validar_diretor,
            "Diretor invalido! Deve ter pelo menos 3 caracteres."
        )

        avaliacao = self.obter_entrada_validada(
            "Avaliacao (0-10, ex: 7.5): ",
            self.validar_avaliacao,
            "Avaliacao invalida! Deve ser entre 0 e 10 com ate 1 casa decimal."
        )

        data_lancamento = self.obter_entrada_validada(
            "Data de lancamento (DD/MM/AAAA): ",
            self.validar_data,
            "Data invalida! Use o formato DD/MM/AAAA."
        )

        print("Duracao do filme:")
        while True:
            try:
                horas = input("   Horas: ").strip()
                minutos = input("   Minutos: ").strip()
                if self.validar_duracao(horas, minutos):
                    break
                print("Duracao invalida! Horas >= 0, minutos entre 0-59.")
            except ValueError:
                print("Digite numeros validos!")

        while True:
            streaming = input("Disponivel em streaming? (s/n): ").strip().lower()
            if streaming in ['s', 'sim']:
                streaming_bool = True
                break
            elif streaming in ['n', 'nao']:
                streaming_bool = False
                break
            print("Digite 's' para sim ou 'n' para nao!")

        return {
            'nome': nome,
            'diretor': diretor,
            'avaliacao': float(avaliacao),
            'data_lancamento': data_lancamento,
            'duracao': (int(horas), int(minutos)),
            'streaming': streaming_bool
        }

    def cadastrar_filmes(self, quantidade: int = 20):
        """Cadastra a quantidade especificada de filmes"""
        print("BEM-VINDO AO SISTEMA DE CATALOGO DE FILMES!")
        print("Vamos cadastrar os filmes de maior bilheteria.\n")

        for i in range(quantidade):
            print(f"Filme {i+1} de {quantidade}")
            filme = self.obter_dados_filme()
            self.filmes.append(filme)
            print("Filme cadastrado com sucesso!")

    def exportar_json(self, nome_arquivo: str = "catalogo_filmes.json"):
        """Exporta os filmes para um arquivo JSON"""
        try:
            with open(nome_arquivo, 'w', encoding='utf-8') as f:
                json.dump(self.filmes, f, ensure_ascii=False, indent=2)
            print(f"\nDados exportados para: {nome_arquivo}")
            print(f"Total de filmes cadastrados: {len(self.filmes)}")
            return True
        except Exception as e:
            print(f"Erro ao exportar arquivo: {e}")
            return False

    def exibir_resumo_cadastro(self):
        """Exibe um resumo dos filmes cadastrados"""
        if not self.filmes:
            print("Nenhum filme cadastrado!")
            return

        print("\n" + "="*60)
        print("RESUMO DO CADASTRO")
        print("="*60)

        for i, filme in enumerate(self.filmes, 1):
            horas, minutos = filme['duracao']
            streaming = "Sim" if filme['streaming'] else "Nao"
            print(f"{i:2d}. {filme['nome']}")
            print(f"   Diretor: {filme['diretor']}")
            print(f"   Avaliacao: {filme['avaliacao']}/10")
            print(f"   Data: {filme['data_lancamento']}")
            print(f"   Duracao: {horas}h{minutos:02d}min")
            print(f"   Streaming: {streaming}")
            print()

def main():
    """Função principal da Etapa 1"""
    cadastro = CadastroFilmes()

    while True:
        try:
            quantidade = int(input("Quantos filmes deseja cadastrar? (padrao: 20): ") or "20")
            if quantidade > 0:
                break
            print("Digite um numero positivo!")
        except ValueError:
            print("Digite um numero valido!")

    cadastro.cadastrar_filmes(quantidade)

    if cadastro.exportar_json():

        cadastro.exibir_resumo_cadastro()

        print("\n" + "="*50)
        print("ETAPA 1 CONCLUIDA COM SUCESSO!")
        print("="*50)
        print("Arquivo JSON gerado: catalogo_filmes.json")
        print("Execute a Etapa 2 para analise estatistica")

if __name__ == "__main__":
    main()

"""Etapa 2: Leitura e obtenção de estatísticas
- Podemos ler estes dados do arquivo JSON
- Obter a média e a mediana da avalição utilizando funções de alta ordem
- Obter uma lista com todos os nomes de filmes cuja avalição é maior que 6, utilizando uma função própria (deve possuir valores default nos parâmetros)
- Obter uma lista com todos os nomes de filmes que existem em algum serviço de streaming, utilizando list-comprehension
- Criar uma função que retorna o filme que possui a maior e o filme que possui a menor duração dentre os cadastrados
- Obter a moda dos diretores (ou seja, o diretor que mais dirigiu filmes)

"""

import json
from collections import Counter
from typing import List, Dict, Tuple, Any

class EstatisticasFilmes:
    def __init__(self, arquivo_json: str = "catalogo_filmes.json"):
        self.arquivo_json = arquivo_json
        self.filmes = self.carregar_dados()

    def carregar_dados(self) -> List[Dict[str, Any]]:
        """Carrega os dados do arquivo JSON usando funcao de alta ordem"""
        try:
            with open(self.arquivo_json, 'r', encoding='utf-8') as f:
                dados = json.load(f)
            print(f"Dados carregados: {len(dados)} filmes")
            return dados
        except FileNotFoundError:
            print(f"Arquivo {self.arquivo_json} nao encontrado!")
            return []
        except json.JSONDecodeError:
            print(f"Erro ao decodificar o arquivo JSON!")
            return []

    def calcular_media_avaliacao(self) -> float:
        """Calcula a media das avaliacoes usando funcoes de alta ordem (map)"""
        if not self.filmes:
            return 0.0

        avaliacoes = list(map(lambda filme: filme['avaliacao'], self.filmes))
        return sum(avaliacoes) / len(avaliacoes)

    def calcular_mediana_avaliacao(self) -> float:
        """Calcula a mediana das avaliacoes usando funcoes de alta ordem (sorted, map)"""
        if not self.filmes:
            return 0.0

        avaliacoes = sorted(map(lambda filme: filme['avaliacao'], self.filmes))
        n = len(avaliacoes)

        return (avaliacoes[n//2 - 1] + avaliacoes[n//2]) / 2 if n % 2 == 0 else avaliacoes[n//2]

    def filmes_acima_avaliacao(self, limite: float = 6.0, ordenar: bool = True) -> List[str]:
        """
        Retorna filmes com avaliacao acima do limite usando funcao propria com parametros default
        Parametros:
        - limite: float = 6.0 (valor default)
        - ordenar: bool = True (valor default)
        """
        if not self.filmes:
            return []

        filmes_filtrados = [
            filme for filme in self.filmes
            if filme['avaliacao'] > limite
        ]

        if ordenar:
            filmes_filtrados.sort(key=lambda x: x['avaliacao'], reverse=True)

        return [filme['nome'] for filme in filmes_filtrados]

    def filmes_em_streaming(self) -> List[str]:
        """Retorna filmes disponiveis em streaming usando list comprehension"""
        return [
            filme['nome'] for filme in self.filmes
            if filme['streaming']
        ]

    def duracao_em_minutos(self, duracao_tuple: Tuple[int, int]) -> int:
        """Converte tupla (horas, minutos) para minutos totais"""
        return duracao_tuple[0] * 60 + duracao_tuple[1]

    def extremos_duracao(self) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Retorna o filme com maior e menor duracao
        Usa funcoes de alta ordem (max, min, lambda)
        """
        if not self.filmes:
            return {}, {}

        mais_longo = max(self.filmes, key=lambda x: self.duracao_em_minutos(x['duracao']))
        mais_curto = min(self.filmes, key=lambda x: self.duracao_em_minutos(x['duracao']))

        return mais_longo, mais_curto

    def moda_diretores(self) -> List[Tuple[str, int]]:
        """Retorna a moda dos diretores (os que mais dirigiram filmes) usando Counter"""
        if not self.filmes:
            return []

        diretores = [filme['diretor'] for filme in self.filmes]

        contador = Counter(diretores)

        if not contador:
            return []

        max_contagem = max(contador.values())

        return [
            (diretor, contagem) for diretor, contagem in contador.items()
            if contagem == max_contagem
        ]

    def formatar_duracao(self, duracao_tuple: Tuple[int, int]) -> str:
        """Formata a duracao para exibicao amigavel"""
        horas, minutos = duracao_tuple
        return f"{horas}h{minutos:02d}min"

    def exibir_estatisticas_completas(self):
        """Exibe todas as estatisticas do catalogo"""
        if not self.filmes:
            print("Nenhum dado disponivel para analise!")
            return

        print("\n" + "="*70)
        print("ANALISE ESTATISTICA DO CATALOGO DE FILMES")
        print("="*70)

        print(f"Total de filmes analisados: {len(self.filmes)}")
        print(f"Media de avaliacoes: {self.calcular_media_avaliacao():.2f}/10")
        print(f"Mediana de avaliacoes: {self.calcular_mediana_avaliacao():.2f}/10")

        filmes_acima_6 = self.filmes_acima_avaliacao()
        print(f"\nFilmes com avaliacao > 6.0: {len(filmes_acima_6)}")
        for i, filme in enumerate(filmes_acima_6, 1):
            avaliacao = next((f['avaliacao'] for f in self.filmes if f['nome'] == filme), "N/A")
            print(f"   {i:2d}. {filme} - {avaliacao}")

        filmes_streaming = self.filmes_em_streaming()
        print(f"\nFilmes disponiveis em streaming: {len(filmes_streaming)}")
        for i, filme in enumerate(filmes_streaming, 1):
            print(f"   {i:2d}. {filme}")

        mais_longo, mais_curto = self.extremos_duracao()
        if mais_longo and mais_curto:
            print(f"\nFilme mais longo: {mais_longo['nome']}")
            print(f"   Diretor: {mais_longo['diretor']}")
            print(f"   Duracao: {self.formatar_duracao(mais_longo['duracao'])}")

            print(f"\nFilme mais curto: {mais_curto['nome']}")
            print(f"   Diretor: {mais_curto['diretor']}")
            print(f"   Duracao: {self.formatar_duracao(mais_curto['duracao'])}")

        moda_diretores = self.moda_diretores()
        if moda_diretores:
            print(f"\nDiretor(es) mais frequente(s):")
            for diretor, contagem in moda_diretores:
                print(f"   {diretor}: {contagem} filme(s)")

                filmes_diretor = [f['nome'] for f in self.filmes if f['diretor'] == diretor]
                for filme in filmes_diretor:
                    print(f"      - {filme}")

        self.exibir_estatisticas_adicionais()

    def exibir_estatisticas_adicionais(self):
        """Exibe estatisticas adicionais interessantes"""
        print(f"\n" + "="*70)
        print("ESTATISTICAS ADICIONAIS")
        print("="*70)

        total_streaming = len(self.filmes_em_streaming())
        porcentagem = (total_streaming / len(self.filmes)) * 100
        print(f"Porcentagem em streaming: {porcentagem:.1f}%")

        melhor_avaliado = max(self.filmes, key=lambda x: x['avaliacao'])
        print(f"Melhor avaliado: {melhor_avaliado['nome']} - {melhor_avaliado['avaliacao']}")

        pior_avaliado = min(self.filmes, key=lambda x: x['avaliacao'])
        print(f"Pior avaliado: {pior_avaliado['nome']} - {pior_avaliado['avaliacao']}")

        duracoes = [self.duracao_em_minutos(f['duracao']) for f in self.filmes]
        duracao_media_min = sum(duracoes) / len(duracoes)
        horas = int(duracao_media_min // 60)
        minutos = int(duracao_media_min % 60)
        print(f"Duracao media: {horas}h{minutos:02d}min")

    def demonstrar_funcoes_avaliacao(self):
        """Demonstra o uso da funcao com parametros default"""
        print(f"\n" + "="*70)
        print("DEMONSTRACAO DA FUNCAO filmes_acima_avaliacao()")
        print("="*70)

        print("Com parametros default (limite=6.0, ordenar=True):")
        filmes_default = self.filmes_acima_avaliacao()
        print(f"   Encontrados: {len(filmes_default)} filmes")

        print("\nCom limite=7.5, ordenar=True:")
        filmes_75 = self.filmes_acima_avaliacao(limite=7.5)
        print(f"   Encontrados: {len(filmes_75)} filmes")
        for filme in filmes_75:
            print(f"      - {filme}")

        print("\nCom limite=6.0, ordenar=False:")
        filmes_nao_ordenados = self.filmes_acima_avaliacao(ordenar=False)
        print(f"   Encontrados: {len(filmes_nao_ordenados)} filmes (ordem original)")

def main():
    print("ETAPA 2: ANALISE ESTATISTICA DE FILMES")
    print("="*55)
    print("Gerando estatisticas a partir do arquivo JSON...")

    estatisticas = EstatisticasFilmes("catalogo_filmes.json")

    if estatisticas.filmes:
        estatisticas.exibir_estatisticas_completas()

        estatisticas.demonstrar_funcoes_avaliacao()

        print(f"\n" + "="*70)
        print("ETAPA 2 CONCLUIDA COM SUCESSO!")
        print("="*70)
    else:
        print("Nao foi possivel carregar dados para analise.")

if __name__ == "__main__":
    main()

"""ETAPAS 3 E 4 - Dados desestruturados

Etapa 3: Lidando com dados desestruturados
- Foi indicado que a média da turma deve ser a mesma média da lista de notas abaixo:

[[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]

- Crie uma função recursiva para obter a média da lista acima
- Utilize esta média e crie uma função para "garantir" que a média da turma fique igual a esta média retornada por essa função
- Atualize as médias dos alunos e exporte os novos dados em formato CSV
"""

import csv
from typing import List, Any, Union

class ProcessadorDadosDesestruturados:
    def __init__(self):
        self.dados_desestruturados = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]

    def achatamento_recursivo(self, dados: Any) -> List[float]:
        """
        Funcao recursiva para achatamento de lista aninhada
        Converte qualquer estrutura aninhada em lista plana de numeros
        """
        lista_plana = []

        if isinstance(dados, (int, float)):
            lista_plana.append(float(dados))
        elif isinstance(dados, list):
            for item in dados:
                lista_plana.extend(self.achatamento_recursivo(item))
        else:
            try:
                lista_plana.append(float(dados))
            except (ValueError, TypeError):
                pass

        return lista_plana

    def calcular_media_recursiva(self, dados: Any = None) -> float:
        """
        Funcao recursiva para calcular media de lista aninhada
        """
        if dados is None:
            dados = self.dados_desestruturados

        lista_plana = self.achatamento_recursivo(dados)

        if not lista_plana:
            return 0.0

        return sum(lista_plana) / len(lista_plana)

    def ajustar_medias_alunos(self, dados_alunos: List[Dict], media_alvo: float) -> List[Dict]:
        """
        Ajusta as medias dos alunos para atingir a media alvo
        Mantem a distribuicao relativa das notas
        """
        if not dados_alunos:
            return []

        medias_atuais = [aluno.get('media', 0) for aluno in dados_alunos]
        media_atual = sum(medias_atuais) / len(medias_atuais) if medias_atuais else 0

        if media_atual == 0:
            return dados_alunos

        fator_ajuste = media_alvo / media_atual

        for aluno in dados_alunos:
            if 'media' in aluno:
                aluno['media_ajustada'] = round(aluno['media'] * fator_ajuste, 2)
                aluno['media_ajustada'] = max(0, min(10, aluno['media_ajustada']))

        return dados_alunos

    def criar_dados_alunos_exemplo(self) -> List[Dict]:
        """
        Cria dados de exemplo de alunos com medias variadas
        """
        return [
            {'id': 1, 'nome': 'Ana Silva', 'media': 8.5},
            {'id': 2, 'nome': 'Carlos Oliveira', 'media': 6.2},
            {'id': 3, 'nome': 'Maria Santos', 'media': 9.1},
            {'id': 4, 'nome': 'Joao Pereira', 'media': 7.3},
            {'id': 5, 'nome': 'Fernanda Costa', 'media': 5.8},
            {'id': 6, 'nome': 'Ricardo Almeida', 'media': 8.9},
            {'id': 7, 'nome': 'Juliana Rodrigues', 'media': 6.7},
            {'id': 8, 'nome': 'Pedro Mendes', 'media': 7.8},
            {'id': 9, 'nome': 'Camila Ferreira', 'media': 4.5},
            {'id': 10, 'nome': 'Lucas Souza', 'media': 9.5}
        ]

    def exportar_csv(self, dados: List[Dict], nome_arquivo: str = 'alunos_medias_ajustadas.csv'):
        """
        Exporta os dados para arquivo CSV
        """
        if not dados:
            print("Nenhum dado para exportar!")
            return False

        try:
            with open(nome_arquivo, 'w', newline='', encoding='utf-8') as csvfile:
                campos = list(dados[0].keys())
                writer = csv.DictWriter(csvfile, fieldnames=campos)

                writer.writeheader()
                for aluno in dados:
                    writer.writerow(aluno)

            print(f"Dados exportados para: {nome_arquivo}")
            return True

        except Exception as e:
            print(f"Erro ao exportar CSV: {e}")
            return False

    def demonstrar_processamento(self):
        """
        Demonstra todo o processo de forma clara
        """
        print("ETAPA 3: PROCESSAMENTO DE DADOS DESESTRUTURADOS")
        print("=" * 55)

        print("Dados desestruturados:")
        print(f"   {self.dados_desestruturados}")

        lista_plana = self.achatamento_recursivo(self.dados_desestruturados)
        print(f"\nLista achatada (recursivo):")
        print(f"   {lista_plana}")
        print(f"   Quantidade de elementos: {len(lista_plana)}")

        media_alvo = self.calcular_media_recursiva()
        print(f"\nMedia calculada (recursiva): {media_alvo:.2f}")

        dados_alunos = self.criar_dados_alunos_exemplo()
        media_original = sum(aluno['media'] for aluno in dados_alunos) / len(dados_alunos)
        print(f"\nDados originais dos alunos:")
        print(f"   Media original da turma: {media_original:.2f}")

        dados_ajustados = self.ajustar_medias_alunos(dados_alunos, media_alvo)
        media_ajustada = sum(aluno['media_ajustada'] for aluno in dados_ajustados) / len(dados_ajustados)
        print(f"   Media ajustada da turma: {media_ajustada:.2f}")

        print(f"\nComparacao das medias:")
        for aluno in dados_ajustados:
            print(f"   {aluno['nome']:15} | Original: {aluno['media']:4.1f} | Ajustada: {aluno['media_ajustada']:4.1f}")

        if self.exportar_csv(dados_ajustados):
            print(f"\nArquivo CSV criado com sucesso!")

        return dados_ajustados

def calcular_media_recursiva(dados: Any) -> float:
    """
    Funcao recursiva pura para calcular media de lista aninhada
    """
    def achatamento_recursivo(item: Any) -> List[float]:
        if isinstance(item, (int, float)):
            return [float(item)]
        elif isinstance(item, list):
            lista_plana = []
            for subitem in item:
                lista_plana.extend(achatamento_recursivo(subitem))
            return lista_plana
        else:
            return []

    lista_plana = achatamento_recursivo(dados)
    return sum(lista_plana) / len(lista_plana) if lista_plana else 0.0

if __name__ == "__main__":
    processador = ProcessadorDadosDesestruturados()

    dados_finais = processador.demonstrar_processamento()

    print(f"\nFuncao recursiva independente:")
    dados_test = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]
    media = calcular_media_recursiva(dados_test)
    print(f"   Media calculada: {media:.2f}")

"""Etapa 4: Tratamento de exceções
- Tratar os possíveis erros do código e exceções

"""

import csv
from typing import List, Any, Union, Dict, Optional

class ProcessadorDadosDesestruturados:
    def __init__(self):
        self.dados_desestruturados = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]

    def achatamento_recursivo(self, dados: Any) -> List[float]:
        """
        Funcao recursiva para achatamento de lista aninhada
        Converte qualquer estrutura aninhada em lista plana de numeros
        """
        lista_plana = []

        try:
            if isinstance(dados, (int, float)):
                lista_plana.append(float(dados))
            elif isinstance(dados, list):
                for item in dados:
                    lista_plana.extend(self.achatamento_recursivo(item))
            elif isinstance(dados, str):
                try:
                    lista_plana.append(float(dados))
                except ValueError:
                    pass
            else:
                try:
                    lista_plana.append(float(dados))
                except (ValueError, TypeError):
                    pass

        except RecursionError:
            print("Erro: Limite de recursao excedido! Verifique dados muito aninhados.")
            return []
        except Exception as e:
            print(f"Erro inesperado em achatamento_recursivo: {e}")
            return []

        return lista_plana

    def calcular_media_recursiva(self, dados: Any = None) -> float:
        """
        Funcao recursiva para calcular media de lista aninhada
        """
        try:
            if dados is None:
                dados = self.dados_desestruturados

            lista_plana = self.achatamento_recursivo(dados)

            if not lista_plana:
                print("Aviso: Lista vazia apos achatamento. Retornando 0.0")
                return 0.0

            media = sum(lista_plana) / len(lista_plana)
            return round(media, 2)

        except ZeroDivisionError:
            print("Erro: Divisao por zero ao calcular media")
            return 0.0
        except TypeError as e:
            print(f"Erro de tipo ao calcular media: {e}")
            return 0.0
        except Exception as e:
            print(f"Erro inesperado em calcular_media_recursiva: {e}")
            return 0.0

    def ajustar_medias_alunos(self, dados_alunos: List[Dict], media_alvo: float) -> List[Dict]:
        """
        Ajusta as medias dos alunos para atingir a media alvo
        Mantem a distribuicao relativa das notas
        """
        if not dados_alunos:
            print("Aviso: Lista de alunos vazia")
            return []

        try:
            if not isinstance(dados_alunos, list):
                raise TypeError("dados_alunos deve ser uma lista")

            if not isinstance(media_alvo, (int, float)):
                raise TypeError("media_alvo deve ser um numero")

            medias_atuais = []
            for aluno in dados_alunos:
                try:
                    if isinstance(aluno, dict) and 'media' in aluno:
                        media_val = aluno['media']
                        if isinstance(media_val, (int, float)):
                            medias_atuais.append(float(media_val))
                        else:
                            print(f"Aviso: Media invalida para aluno {aluno.get('nome', 'Desconhecido')}")
                except (KeyError, TypeError, ValueError) as e:
                    print(f"Aviso: Erro ao processar media do aluno: {e}")
                    continue

            if not medias_atuais:
                print("Erro: Nenhuma media valida encontrada")
                return dados_alunos

            media_atual = sum(medias_atuais) / len(medias_atuais)

            if media_atual == 0:
                print("Aviso: Media atual e zero, nao e possivel ajustar")
                return dados_alunos

            fator_ajuste = media_alvo / media_atual

            for aluno in dados_alunos:
                try:
                    if isinstance(aluno, dict) and 'media' in aluno:
                        media_original = aluno['media']
                        if isinstance(media_original, (int, float)):
                            media_ajustada = round(media_original * fator_ajuste, 2)
                            aluno['media_ajustada'] = max(0.0, min(10.0, media_ajustada))
                        else:
                            aluno['media_ajustada'] = 0.0
                except (TypeError, ValueError) as e:
                    print(f"Erro ao ajustar media do aluno {aluno.get('nome', 'Desconhecido')}: {e}")
                    aluno['media_ajustada'] = 0.0

            return dados_alunos

        except ZeroDivisionError:
            print("Erro: Divisao por zero no ajuste de medias")
            return dados_alunos
        except Exception as e:
            print(f"Erro inesperado em ajustar_medias_alunos: {e}")
            return dados_alunos

    def criar_dados_alunos_exemplo(self) -> List[Dict]:
        """
        Cria dados de exemplo de alunos com medias variadas
        """
        try:
            return [
                {'id': 1, 'nome': 'Ana Silva', 'media': 8.5},
                {'id': 2, 'nome': 'Carlos Oliveira', 'media': 6.2},
                {'id': 3, 'nome': 'Maria Santos', 'media': 9.1},
                {'id': 4, 'nome': 'Joao Pereira', 'media': 7.3},
                {'id': 5, 'nome': 'Fernanda Costa', 'media': 5.8},
                {'id': 6, 'nome': 'Ricardo Almeida', 'media': 8.9},
                {'id': 7, 'nome': 'Juliana Rodrigues', 'media': 6.7},
                {'id': 8, 'nome': 'Pedro Mendes', 'media': 7.8},
                {'id': 9, 'nome': 'Camila Ferreira', 'media': 4.5},
                {'id': 10, 'nome': 'Lucas Souza', 'media': 9.5}
            ]
        except Exception as e:
            print(f"Erro ao criar dados de exemplo: {e}")
            return []

    def exportar_csv(self, dados: List[Dict], nome_arquivo: str = 'alunos_medias_ajustadas.csv') -> bool:
        """
        Exporta os dados para arquivo CSV com tratamento robusto de erros
        """
        if not dados:
            print("Nenhum dado para exportar!")
            return False

        if not isinstance(dados, list) or not all(isinstance(item, dict) for item in dados):
            print("Dados devem ser uma lista de dicionarios")
            return False

        try:
            with open(nome_arquivo, 'w', newline='', encoding='utf-8') as csvfile:
                campos = list(dados[0].keys())
                writer = csv.DictWriter(csvfile, fieldnames=campos)

                writer.writeheader()
                for i, aluno in enumerate(dados):
                    try:
                        writer.writerow(aluno)
                    except ValueError as e:
                        print(f"Aviso: Erro ao escrever linha {i+1}: {e}")
                        linha_sanitizada = {k: str(v) for k, v in aluno.items()}
                        writer.writerow(linha_sanitizada)

            print(f"Dados exportados para: {nome_arquivo}")
            return True

        except PermissionError:
            print(f"Erro de permissao: Nao e possivel escrever no arquivo {nome_arquivo}")
            return False
        except FileNotFoundError:
            print(f"Erro: Caminho invalido para o arquivo {nome_arquivo}")
            return False
        except Exception as e:
            print(f"Erro inesperado ao exportar CSV: {e}")
            return False

    def testar_cenarios_erro(self):
        """
        Testa diversos cenarios de erro para demonstrar o tratamento
        """
        print("\n" + "="*60)
        print("TESTANDO CENARIOS DE ERRO")
        print("="*60)

        print("\n1. Testando dados invalidos na lista:")
        dados_invalidos = [[6.3, "texto", [8.4, None, 5.1], 9.6], [], "string", {"dict": "value"}]
        media_invalida = self.calcular_media_recursiva(dados_invalidos)
        print(f"   Media com dados invalidos: {media_invalida:.2f}")

        print("\n2. Testando lista vazia:")
        media_vazia = self.calcular_media_recursiva([])
        print(f"   Media de lista vazia: {media_vazia:.2f}")

        print("\n3. Testando ajuste com media zero:")
        alunos_media_zero = [{'nome': 'Teste', 'media': 0}]
        ajustados = self.ajustar_medias_alunos(alunos_media_zero, 6.41)
        print(f"   Resultado: {ajustados}")

        print("\n4. Testando exportacao para caminho invalido:")
        dados_teste = [{'teste': 'valor'}]
        resultado = self.exportar_csv(dados_teste, '/caminho/invalido/arquivo.csv')
        print(f"   Exportacao bem-sucedida: {resultado}")

    def demonstrar_processamento(self):
        """
        Demonstra todo o processo de forma clara com tratamento de erros
        """
        print("ETAPA 4: PROCESSAMENTO COM TRATAMENTO DE EXCECOES")
        print("=" * 60)

        try:
            print("Dados desestruturados:")
            print(f"   {self.dados_desestruturados}")

            lista_plana = self.achatamento_recursivo(self.dados_desestruturados)
            print(f"\nLista achatada (recursivo):")
            print(f"   {lista_plana}")
            print(f"   Quantidade de elementos: {len(lista_plana)}")

            media_alvo = self.calcular_media_recursiva()
            print(f"\nMedia calculada (recursiva): {media_alvo:.2f}")

            dados_alunos = self.criar_dados_alunos_exemplo()
            if not dados_alunos:
                raise ValueError("Nao foi possivel criar dados de exemplo")

            media_original = sum(aluno['media'] for aluno in dados_alunos) / len(dados_alunos)
            print(f"\nDados originais dos alunos:")
            print(f"   Media original da turma: {media_original:.2f}")

            dados_ajustados = self.ajustar_medias_alunos(dados_alunos, media_alvo)
            if not dados_ajustados:
                raise ValueError("Falha no ajuste de medias")

            media_ajustada = sum(aluno.get('media_ajustada', 0) for aluno in dados_ajustados) / len(dados_ajustados)
            print(f"   Media ajustada da turma: {media_ajustada:.2f}")

            print(f"\nComparacao das medias:")
            for aluno in dados_ajustados:
                print(f"   {aluno['nome']:18} | Original: {aluno['media']:4.1f} | Ajustada: {aluno.get('media_ajustada', 'N/A'):4.1f}")

            if self.exportar_csv(dados_ajustados):
                print(f"\nArquivo CSV criado com sucesso!")

            return dados_ajustados

        except Exception as e:
            print(f"ERRO CRITICO no processamento: {e}")
            return []

def calcular_media_recursiva(dados: Any) -> float:
    """
    Funcao recursiva pura para calcular media de lista aninhada
    com tratamento robusto de excecoes
    """
    def achatamento_recursivo(item: Any) -> List[float]:
        try:
            if isinstance(item, (int, float)):
                return [float(item)]
            elif isinstance(item, list):
                lista_plana = []
                for subitem in item:
                    lista_plana.extend(achatamento_recursivo(subitem))
                return lista_plana
            elif isinstance(item, str):
                try:
                    return [float(item)]
                except ValueError:
                    return []
            else:
                return []
        except RecursionError:
            print("Erro: Limite de recursao excedido!")
            return []
        except Exception as e:
            print(f"Erro inesperado em achatamento recursivo: {e}")
            return []

    try:
        lista_plana = achatamento_recursivo(dados)
        if not lista_plana:
            return 0.0
        return round(sum(lista_plana) / len(lista_plana), 2)
    except ZeroDivisionError:
        return 0.0
    except Exception as e:
        print(f"Erro inesperado no calculo da media: {e}")
        return 0.0

if __name__ == "__main__":
    try:
        processador = ProcessadorDadosDesestruturados()

        dados_finais = processador.demonstrar_processamento()

        processador.testar_cenarios_erro()

        print(f"\nFuncao recursiva independente:")
        dados_test = [[6.3, 2.1, [8.4, 4.2, 5.1], 9.6], 10, 4.7, 6.5]
        media = calcular_media_recursiva(dados_test)
        print(f"   Media calculada: {media:.2f}")

        print(f"\nTeste com dados problematicos:")
        dados_problematicos = ["texto", None, [], [1, 2, "3a"]]
        media_problema = calcular_media_recursiva(dados_problematicos)
        print(f"   Media de dados problematicos: {media_problema:.2f}")

    except KeyboardInterrupt:
        print("\nExecucao interrompida pelo usuario")
    except Exception as e:
        print(f"ERRO GRAVE nao tratado: {e}")
    finally:
        print("\nExecucao concluida com tratamento de excecoes completo!")